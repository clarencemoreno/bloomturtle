package ratelimiter_bloom

import (
	"context"
	"testing"
	"time"

	"github.com/clarencemoreno/bloomturtle/internal/event"
)

// MockEventListener is a mock implementation of the EventListener interface for testing purposes.
type MockEventListener struct {
	receivedEvents []event.Event
}

func (mel *MockEventListener) HandleEvent(ctx context.Context, e event.Event) error {
	mel.receivedEvents = append(mel.receivedEvents, e)
	return nil
}

func TestRateLimiter(t *testing.T) {
	primaryCapacity := 5
	secondaryCapacity := 3
	rate := 2

	rl := NewRateLimiter(primaryCapacity, secondaryCapacity, rate)

	mockListener := &MockEventListener{}
	rl.AddListener(mockListener)

	key := "testKey"

	// Test initial state with primary tokens full
	for i := 0; i < primaryCapacity; i++ {
		if !rl.Allow(key) {
			t.Errorf("Expected request %d to be allowed, but it was denied", i+1)
		}
	}

	// Test transition to secondary tokens
	for i := 0; i < secondaryCapacity; i++ {
		if !rl.Allow(key) {
			t.Errorf("Expected request %d to be allowed, but it was denied", primaryCapacity+i+1)
		}
	}

	// Test exhaustion of both buckets
	if rl.Allow(key) {
		t.Errorf("Expected request to be denied, but it was allowed")
	}

	// Check if the event was generated
	if len(mockListener.receivedEvents) != 1 {
		t.Errorf("Expected 1 event to be generated, but got %d", len(mockListener.receivedEvents))
	}

	event := mockListener.receivedEvents[0].(RateLimitEvent)
	if event.Key != key {
		t.Errorf("Expected event key to be %s, but got %s", key, event.Key)
	}

	// Test refill mechanism
	time.Sleep(1 * time.Second) // Wait for at least one token to be refilled

	mutex := rl.getMutex(key)
	mutex.Lock()
	rl.refill(key)
	mutex.Unlock()

	if !rl.Allow(key) {
		t.Errorf("Expected request to be allowed after refill, but it was denied")
	}
}
