package ratelimiter_bloom

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/clarencemoreno/bloomturtle/internal/event"
)

// Storekeeper is an implementation of EventListener that handles rate limit events.
type Storekeeper struct {
	eventPublisher *event.BaseEventPublisher
}

// NewStorekeeper creates a new Storekeeper.
func NewStorekeeper(eventPublisher *event.BaseEventPublisher) *Storekeeper {
	return &Storekeeper{eventPublisher: eventPublisher}
}

// HandleEvent processes rate limit events.
func (sk *Storekeeper) HandleEvent(ctx context.Context, e event.Event) error {
	event := e.(RateLimitEvent)
	fmt.Printf("\nRate limit event: Key=%s, Message=%s, Timestamp=%s\n", event.Key, event.Message, event.Timestamp)
	return nil
}

// RateLimiter controls the rate of requests using a two-bucket leaky bucket algorithm
type RateLimiter struct {
	primaryCapacity   int                 // Capacity of the primary bucket
	secondaryCapacity int                 // Capacity of the secondary bucket (leaky bucket)
	rate              int                 // Refill rate of the secondary bucket (tokens per second)
	primaryTokens     *BloomFilterCounter // Current number of tokens in the primary bucket
	secondaryTokens   *BloomFilterCounter // Current number of tokens in the secondary bucket
	lastRefillTime    sync.Map            // Last time the buckets were refilled for each key
	eventPub          *event.BaseEventPublisher
	mutexes           sync.Map // Map of mutexes for each key
}

// NewRateLimiter creates a new RateLimiter with the specified capacities and refill rate
func NewRateLimiter(primaryCapacity int, secondaryCapacity int, rate int) *RateLimiter {
	rl := &RateLimiter{
		primaryCapacity:   primaryCapacity,
		secondaryCapacity: secondaryCapacity,
		rate:              rate,
		primaryTokens:     NewBloomFilterCounter(primaryCapacity),   // Initially, the primary bucket is full
		secondaryTokens:   NewBloomFilterCounter(secondaryCapacity), // Initially, the secondary bucket is full
		eventPub:          event.NewBaseEventPublisher(),
	}
	rl.eventPub.Start()
	return rl
}

// getMutex retrieves or creates a mutex for the given key
func (rl *RateLimiter) getMutex(key string) *sync.Mutex {
	mutex, _ := rl.mutexes.LoadOrStore(key, &sync.Mutex{})
	return mutex.(*sync.Mutex)
}

// refill refills the secondary bucket first, then the primary bucket if the secondary is full
func (rl *RateLimiter) refill(key string) {
	mutex := rl.getMutex(key)
	mutex.Lock()
	defer mutex.Unlock()

	now := time.Now()
	lastRefillTime, _ := rl.lastRefillTime.LoadOrStore(key, now)
	elapsed := now.Sub(lastRefillTime.(time.Time)).Seconds()
	newTokens := int(elapsed * float64(rl.rate))
	if newTokens > 0 {
		rl.lastRefillTime.Store(key, now)
		// Refill the secondary bucket
		rl.secondaryTokens.Add(key, newTokens)
		if rl.secondaryTokens.CheckCount(key) > rl.secondaryCapacity {
			overflow := rl.secondaryTokens.CheckCount(key) - rl.secondaryCapacity
			rl.secondaryTokens.Add(key, -overflow) // Decrement the overflow
			rl.primaryTokens.Add(key, overflow)    // Add overflow to primary bucket
			if rl.primaryTokens.CheckCount(key) > rl.primaryCapacity {
				rl.primaryTokens.Add(key, -(rl.primaryTokens.CheckCount(key) - rl.primaryCapacity))
			}
		}
	}
}

// Allow checks if a request can be processed
func (rl *RateLimiter) Allow(key string) bool {
	mutex := rl.getMutex(key)
	mutex.Lock()
	defer mutex.Unlock()

	// Refill outside the mutex lock
	rl.refill(key)

	if rl.primaryTokens.Check(key) {
		rl.primaryTokens.Decrement(key)
		return true
	}

	if rl.secondaryTokens.Check(key) {
		rl.secondaryTokens.Decrement(key)
		return true
	}

	// Generate event when both buckets are empty
	rl.generateEvent(key)
	return false
}

// generateEvent is called when both buckets are exhausted
func (rl *RateLimiter) generateEvent(key string) {
	event := RateLimitEvent{
		Key:                 key,
		Timestamp:           time.Now(),
		Message:             "Both primary and secondary buckets are exhausted.",
		ExpirationTimestamp: time.Now().Add(500 * time.Millisecond), // Expiration timestamp set to 0.5 seconds from now
	}
	rl.eventPub.PublishEvent(event)
}

// AddListener adds an event listener to the rate limiter.
func (rl *RateLimiter) AddListener(listener event.EventListener) {
	rl.eventPub.AddListener(listener)
}

// Shutdown stops the event publisher and waits for it to finish.
func (rl *RateLimiter) Shutdown(ctx context.Context) error {
	return rl.eventPub.Shutdown(ctx)
}

// RateLimitEvent represents an event when both buckets are exhausted.
type RateLimitEvent struct {
	Key                 string
	Timestamp           time.Time
	Message             string
	ExpirationTimestamp time.Time
}
